(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SmartLabel"] = factory();
	else
		root["SmartLabel"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/SmartlabelManager.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/SmartlabelManager.js":
/*!**********************************!*\
  !*** ./src/SmartlabelManager.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.js\");\n/* harmony import */ var _container_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./container-manager */ \"./src/container-manager.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar slLib = _lib__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init(window),\n    doc = slLib.win.document,\n    M = slLib.win.Math,\n    max = M.max,\n    round = M.round,\n    htmlSplCharSpace = {\n  ' ': '&nbsp;'\n},\n    documentSupport = slLib.getDocumentSupport(),\n    SVG_BBOX_CORRECTION = documentSupport.isWebKit ? 0 : 4.5;\n/*\n * @constrcutor\n * SmartLabelManager controls the lifetime of the execution space where the text's metrics will be calculated.\n * This takes a string for a given style and returns the height, width.\n * If a bound box is defined it wraps the text and returns the wrapped height and width.\n * It allows to append ellipsis at the end if the text is truncated.\n *\n * @param {String | HTMLElement} container - The id or the instance of the container where the intermediate dom\n *                              elements are to be attached. If not passed, it appends in div\n *\n * @param {Boolean} useEllipses - This decides if a ellipses to be appended if the text is truncated.\n * @param {Object} options - Control options\n *                          {\n *                              maxCacheLimit: No of letter to be cached. Default: 500.\n *                          }\n */\n\nfunction SmartLabelManager(container, useEllipses, options) {\n  var wrapper,\n      prop,\n      max,\n      isBrowserLess = false,\n      canvas = window.document.createElement('canvas');\n  options = options || {};\n  options.maxCacheLimit = isFinite(max = options.maxCacheLimit) ? max : slLib.maxDefaultCacheLimit;\n\n  if (typeof container === 'string') {\n    container = doc.getElementById(container);\n  }\n\n  wrapper = slLib.createContainer(container);\n  wrapper.innerHTML = slLib.testStrAvg;\n\n  if (documentSupport.isHeadLess || !documentSupport.isIE && !wrapper.offsetHeight && !wrapper.offsetWidth) {\n    isBrowserLess = true;\n  }\n\n  wrapper.innerHTML = '';\n\n  for (prop in slLib.parentContainerStyle) {\n    wrapper.style[prop] = slLib.parentContainerStyle[prop];\n  }\n\n  this.parentContainer = wrapper; // Get a context of canvas\n\n  this.ctx = canvas && canvas.getContext && canvas.getContext('2d');\n  this._containerManager = new _container_manager__WEBPACK_IMPORTED_MODULE_1__[\"default\"](wrapper, isBrowserLess, 10);\n  this._showNoEllipses = !useEllipses;\n  this._init = true;\n  this.style = {};\n  this.oldStyle = {};\n  this.options = options;\n  this.setStyle();\n}\n/*\n * getSmartText returns the text separated by <br/> whenever a break is necessary. This is to recgonize one\n * generalized format independent of the implementation (canvas based solution, svg based solution). This method\n * converts the output of getSmartText().text to array of lines if the text is wrapped. It sets a named property\n * `lines` on the object passed as parameter.\n *\n * @param {Object} smartlabel - the object returned by getSmartText based on which line arr which to be formed.\n *\n * @return {Object} - The same object which was passed in the arguments. Also a named property `lines` is set.\n */\n\n\nSmartLabelManager.textToLines = function (smartlabel) {\n  smartlabel = smartlabel || {};\n\n  if (!smartlabel.text) {\n    smartlabel.text = '';\n  } else if (typeof smartlabel.text !== 'string') {\n    smartlabel.text = smartlabel.text.toString();\n  }\n\n  smartlabel.lines = smartlabel.text.split(/\\n|<br\\s*?\\/?>/ig);\n  return smartlabel;\n}; // Calculates space taken by a character with an approximation value which is calculated by repeating the\n// character by string length times.\n\n\nSmartLabelManager.prototype._calCharDimWithCache = function () {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var calculateDifference = arguments.length > 1 ? arguments[1] : undefined;\n  var length = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (!this._init) {\n    return false;\n  }\n\n  var size,\n      tw,\n      twi,\n      cachedStyle,\n      asymmetricDifference,\n      maxAdvancedCacheLimit = this.options.maxCacheLimit,\n      style = this.style || {},\n      cache,\n      advancedCacheKey,\n      cacheName,\n      cacheInitName;\n  cache = this._advancedCache = this._advancedCache || (this._advancedCache = {});\n  advancedCacheKey = this._advancedCacheKey || (this._advancedCacheKey = []);\n  cacheName = text + style.fontSize + style.fontFamily + style.fontWeight + style.fontStyle;\n  cacheInitName = text + 'init' + style.fontSize + style.fontFamily + style.fontWeight + style.fontStyle;\n\n  if (!this.ctx && htmlSplCharSpace[text]) {\n    text = htmlSplCharSpace[text];\n  }\n\n  if (!calculateDifference) {\n    asymmetricDifference = 0;\n  } else {\n    if ((asymmetricDifference = cache[cacheInitName]) === undefined) {\n      tw = this._getDimention(text.repeat ? text.repeat(length) : Array(length + 1).join(text)).width;\n      twi = this._getDimention(text).width;\n      asymmetricDifference = cache[cacheInitName] = (tw - length * twi) / (length + 1);\n      advancedCacheKey.push(cacheInitName);\n\n      if (advancedCacheKey.length > maxAdvancedCacheLimit) {\n        delete cache[advancedCacheKey.shift()];\n      }\n    }\n  }\n\n  if (cachedStyle = cache[cacheName]) {\n    return {\n      width: cachedStyle.width,\n      height: cachedStyle.height\n    };\n  }\n\n  size = this._getDimention(text);\n  size.width += asymmetricDifference;\n  cache[cacheName] = {\n    width: size.width,\n    height: size.height\n  };\n  advancedCacheKey.push(cacheName);\n\n  if (advancedCacheKey.length > maxAdvancedCacheLimit) {\n    delete cache[advancedCacheKey.shift()];\n  }\n\n  return size;\n};\n\nSmartLabelManager.prototype._getDimention = function (text) {\n  if (this.requireDiv || !this.ctx) {\n    return slLib._getDimentionUsingDiv(text, this);\n  } else {\n    return slLib._getDimentionUsingCanvas(text, this);\n  }\n}; // Provide function to calculate the height and width based on the environment and available support from dom.\n\n\nSmartLabelManager.prototype._getWidthFn = function () {\n  var sl = this,\n      contObj = sl._containerObj,\n      svgText = contObj.svgText;\n\n  if (svgText) {\n    return function (str) {\n      var bbox, width;\n      svgText.textContent = str;\n      bbox = svgText.getBBox();\n      width = bbox.width - SVG_BBOX_CORRECTION;\n\n      if (width < 1) {\n        width = bbox.width;\n      }\n\n      return width;\n    };\n  } else {\n    return function (str) {\n      if (sl.requireDiv || !sl.ctx) {\n        return slLib._getDimentionUsingDiv(str, sl).width;\n      } else {\n        return slLib._getDimentionUsingCanvas(str, sl).width;\n      }\n    };\n  }\n};\n/**\n * Checks if two style object contains the same properties from the following list\n * - font-size\n * - font-family\n * - font-style\n * - font-weight\n * - font-variant\n */\n\n\nSmartLabelManager.prototype._isSameStyle = function () {\n  var sl = this,\n      oldStyle = sl.oldStyle || {},\n      style = sl.style;\n\n  if (style.fontSize !== oldStyle.fontSize || style.fontFamily !== oldStyle.fontFamily || style.fontStyle !== oldStyle.fontStyle || style.fontWeight !== oldStyle.fontWeight || style.fontVariant !== oldStyle.fontVariant) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Sets font property of canvas context based on which the width of text is calculated.\n *\n * @param {any} style style configuration which affects the text size\n *                      {\n *                          fontSize / 'font-size' : MUST BE FOLLOWED BY PX (10px, 11px)\n *                          fontFamily / 'font-family'\n *                          fontWeight / 'font-weight'\n *                          fontStyle / 'font-style'\n *                      }\n */\n\n\nSmartLabelManager.prototype._setStyleOfCanvas = function () {\n  if (this._isSameStyle()) {\n    return;\n  }\n\n  var sl = this,\n      style = sl.style,\n      hashString,\n      sCont,\n      fontStyle = style.fontStyle,\n      fontVariant = style.fontVariant,\n      fontWeight = style.fontWeight,\n      fontSize = style.fontSize,\n      fontFamily = style.fontFamily;\n  fontSize += fontSize.indexOf('px') === -1 ? 'px' : '';\n  hashString = fontStyle + ' ' + fontVariant + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily;\n  sl.ctx.font = hashString;\n  sCont = this._containerObj = this._containerManager.get(style);\n\n  if (this._containerObj) {\n    this._container = sCont.node;\n    this._context = sCont.context;\n    this._cache = sCont.charCache;\n    this._lineHeight = sCont.lineHeight;\n    this._styleNotSet = false;\n  } else {\n    this._styleNotSet = true;\n  }\n\n  sCont.ellipsesWidth = sl._calCharDimWithCache('...', false).width;\n  sCont.dotWidth = sl._calCharDimWithCache('.', false).width;\n  sCont.lineHeight = this._lineHeight = sCont.lineHeight || slLib._getCleanHeight(style.lineHeight);\n  this.oldStyle = style;\n};\n\nSmartLabelManager.prototype._setStyleOfDiv = function () {\n  var sCont,\n      style = this.style;\n  this._containerObj = sCont = this._containerManager.get(style);\n\n  if (!sCont.node) {\n    this._containerManager._makeDivNode(this._containerObj);\n  }\n\n  if (this._containerObj) {\n    this._container = sCont.node;\n    this._context = sCont.context;\n    this._cache = sCont.charCache;\n    this._lineHeight = sCont.lineHeight;\n    this._styleNotSet = false;\n  } else {\n    this._styleNotSet = true;\n  }\n};\n\nSmartLabelManager.prototype._updateStyle = function () {\n  return this.requireDiv || !this.ctx ? this._setStyleOfDiv() : this._setStyleOfCanvas();\n};\n/*\n * Sets the style based on which the text's metrics to be calculated.\n *\n * @param {Object} style - The style object which affects the text size\n *                      {\n *                          fontSize / 'font-size' : MUST BE FOLLOWED BY PX (10px, 11px)\n *                          fontFamily / 'font-family'\n *                          fontWeight / 'font-weight'\n *                          fontStyle / 'font-style'\n *                      }\n *\n * @return {SmartLabelManager} - Current instance of SmartLabelManager\n */\n\n\nSmartLabelManager.prototype.setStyle = function (style) {\n  this.style = slLib.parseStyle(style);\n  slLib.setLineHeight(this.style);\n  return this;\n};\n/*\n * Decides whether ellipses to be shown if the node is truncated\n *\n * @param {Boolean} useEllipses - decides if a ellipses to be appended if the text is truncated. Default: false\n *\n * @return {SmartLabelManager} - Current instance of SmartLabelManager\n */\n\n\nSmartLabelManager.prototype.useEllipsesOnOverflow = function (useEllipses) {\n  if (!this._init) {\n    return this;\n  }\n\n  this._showNoEllipses = !useEllipses;\n  return this;\n};\n/*\n * Get wrapped or truncated text if a bound box is defined around it. The result text would be separated by <br/>\n * if wrapped\n *\n * @param {String} text - the subject text\n * @param {Number} maxWidth - width in px of the the bound box\n * @param {Number} maxHeight - height in px of the the bound box\n * @param {Boolean} noWrap - whether the text to be wrapped. Default false.\n *\n * @return {Object} - The metrics of the text bounded by the box\n *                  {\n *                      height : height of the wrapped text\n *                      width : width of the wrapped text\n *                      isTruncated : whether the text is truncated\n *                      maxHeight : Maximum height given\n *                      maxWidth : Maximum width given\n *                      oriText : Original text sent\n *                      oriTextHeight : Original text height\n *                      oriTextWidth : Original text width\n *                      text : SMART TEXT\n *                  }\n */\n\n\nSmartLabelManager.prototype.getSmartText = function (text, maxWidth, maxHeight, noWrap) {\n  if (!this._init) {\n    return false;\n  }\n\n  if (text === undefined || text === null) {\n    text = '';\n  } else if (typeof text !== 'string') {\n    text = text.toString();\n  }\n\n  var len,\n      trimStr,\n      tempArr,\n      tmpText,\n      maxWidthWithEll,\n      toolText,\n      oriWidth,\n      oriHeight,\n      newCharIndex,\n      nearestChar,\n      tempChar,\n      getWidth,\n      initialLeft,\n      initialTop,\n      getOriSizeImproveObj,\n      spanArr,\n      x,\n      y,\n      minWidth,\n      elem,\n      chr,\n      elemRightMostPoint,\n      elemLowestPoint,\n      lastBR,\n      removeFromIndex,\n      removeFromIndexForEllipses,\n      hasHTMLTag = false,\n      maxStrWidth = 0,\n      lastDash = -1,\n      lastSpace = -1,\n      lastIndexBroken = -1,\n      strWidth = 0,\n      strHeight = 0,\n      oriTextArr = [],\n      i = 0,\n      ellipsesStr = this._showNoEllipses ? '' : '...',\n      lineHeight,\n      context,\n      container,\n      sCont,\n      ellipsesWidth,\n      dotWidth,\n      canvas = this.ctx,\n      characterArr = [],\n      dashIndex = -1,\n      spaceIndex = -1,\n      lastLineBreak = -1,\n      hasOnlyBrTag,\n      dimentionObj,\n      fastTrim = function fastTrim(str) {\n    str = str.replace(/^\\s\\s*/, '');\n    var ws = /\\s/,\n        i = str.length;\n\n    while (ws.test(str.charAt(i -= 1))) {\n      /* jshint noempty:false */\n    }\n\n    return str.slice(0, i + 1);\n  },\n      smartLabel = {\n    text: text,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    width: null,\n    height: null,\n    oriTextWidth: null,\n    oriTextHeight: null,\n    oriText: text,\n    isTruncated: false\n  };\n\n  hasHTMLTag = slLib.xmlTagRegEx.test(text) || slLib.nbspRegex.test(text);\n  hasOnlyBrTag = slLib._hasOnlyBRTag(text);\n  this.requireDiv = hasHTMLTag && !hasOnlyBrTag;\n\n  this._updateStyle();\n\n  lineHeight = this._lineHeight;\n  context = this._context;\n  container = this._container;\n  sCont = this._containerObj;\n  ellipsesWidth = sCont.ellipsesWidth;\n  dotWidth = sCont.dotWidth;\n  toolText = text.replace(slLib.spanAdditionRegx, '$2');\n  getWidth = this._getWidthFn(); // In some browsers, offsetheight of a single-line text is getting little (1 px) heigher value of the\n  // lineheight. As a result, smartLabel is unable to return single-line text.\n  // To fix this, increase the maxHeight a little amount. Hence maxHeight =  lineHeight * 1.2\n\n  /**\n   * For canvas lineHeight is directly used. In some cases, lineHeight can be 0.x pixels greater than\n   * maxHeight. Previously, div was used to calculate lineHeight and it used to return a rounded number.\n   *\n   * Adding a buffer of 1px, maxheight will be increased by a factor of 1.2 only when\n   * 0 <= (lineHeight - maxHeight) <= 1\n   */\n\n  if (lineHeight - maxHeight <= 1 && lineHeight - maxHeight >= 0) {\n    maxHeight *= 1.2;\n  }\n\n  if (canvas || container) {\n    if (!documentSupport.isBrowserLess) {\n      if (!hasHTMLTag) {\n        // Due to support of <,>, \", ' for xml we convert &lt;, &gt;, &quot;, &#034;, &#039; to <, >, \", \", ' respectively so to get the correct\n        // width it is required to convert the same before calculation for the new improve version of the\n        // get text width.\n        tmpText = text = text.replace(slLib.ltgtquotRegex, function (match) {\n          switch (match) {\n            case '&lt;':\n              return '<';\n\n            case '&gt;':\n              return '>';\n\n            case '&quot;':\n              return '\"';\n\n            case '&#034;':\n              return '\"';\n\n            case '&#039;':\n              return '\\'';\n          }\n        });\n        getOriSizeImproveObj = this.getSize(tmpText, true, {\n          hasHTMLTag: hasHTMLTag,\n          hasOnlyBrTag: hasOnlyBrTag,\n          cleanText: true\n        });\n        smartLabel.oriTextWidth = oriWidth = getOriSizeImproveObj.width;\n        smartLabel.oriTextHeight = oriHeight = getOriSizeImproveObj.height;\n      } else if (hasOnlyBrTag) {\n        text = text.replace(slLib.brRegex, '<br />');\n        dimentionObj = slLib._getDimentionOfMultiLineText(text, this);\n        smartLabel.oriTextWidth = oriWidth = dimentionObj.width;\n        smartLabel.oriTextHeight = oriHeight = dimentionObj.height;\n      } else {\n        container.innerHTML = text;\n        smartLabel.oriTextWidth = oriWidth = container.offsetWidth;\n        smartLabel.oriTextHeight = oriHeight = container.offsetHeight;\n      }\n\n      if (oriHeight <= maxHeight && oriWidth <= maxWidth) {\n        smartLabel.width = smartLabel.oriTextWidth = oriWidth;\n        smartLabel.height = smartLabel.oriTextHeight = oriHeight;\n        return smartLabel;\n      }\n\n      if (lineHeight > maxHeight) {\n        smartLabel.text = '';\n        smartLabel.width = smartLabel.oriTextWidth = 0;\n        smartLabel.height = smartLabel.oriTextHeight = 0;\n        return smartLabel;\n      }\n    } // Calculate width with ellipses\n\n\n    text = fastTrim(text).replace(/(\\s+)/g, ' ');\n    maxWidthWithEll = this._showNoEllipses ? maxWidth : maxWidth - ellipsesWidth; // Checks if any html tag is present. This if block is executed for all normal texts and\n    // all texts containing only <br /> tag.\n\n    if (!hasHTMLTag || hasOnlyBrTag) {\n      // Gets splitted array\n      oriTextArr = slLib._getTextArray(text);\n      len = oriTextArr.length;\n      trimStr = '';\n      tempArr = [];\n      tempChar = oriTextArr[0];\n\n      if (this._cache[tempChar]) {\n        minWidth = this._cache[tempChar].width;\n      } else {\n        minWidth = getWidth(tempChar);\n        this._cache[tempChar] = {\n          width: minWidth\n        };\n      }\n\n      if (maxWidthWithEll > minWidth && !hasOnlyBrTag) {\n        tempArr = text.substr(0, slLib.getNearestBreakIndex(text, maxWidthWithEll, this)).split('');\n      } else if (minWidth > maxWidth) {\n        smartLabel.text = '';\n        smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;\n        return smartLabel;\n      } else if (ellipsesStr) {\n        maxWidthWithEll = maxWidth - 2 * dotWidth;\n\n        if (maxWidthWithEll > minWidth) {\n          ellipsesStr = '..';\n        } else {\n          maxWidthWithEll = maxWidth - dotWidth;\n\n          if (maxWidthWithEll > minWidth) {\n            ellipsesStr = '.';\n          } else {\n            maxWidthWithEll = 0;\n            ellipsesStr = '';\n          }\n        }\n      }\n\n      i = tempArr.length;\n      strWidth = getWidth(tempArr.join(''));\n      strHeight = this._lineHeight;\n\n      if (noWrap) {\n        for (; i < len; i += 1) {\n          tempChar = tempArr[i] = oriTextArr[i]; // In case of <br>, reset width to 0 and increase line height\n\n          if (tempArr[i] === '<br />') {\n            strHeight += this._lineHeight;\n            lastIndexBroken = i;\n            maxStrWidth = max(maxStrWidth, strWidth);\n            strWidth = 0;\n            trimStr = null;\n            continue;\n          }\n\n          if (this._cache[tempChar]) {\n            minWidth = this._cache[tempChar].width;\n          } else {\n            if (!getOriSizeImproveObj || !(minWidth = getOriSizeImproveObj.detailObj[tempChar])) {\n              minWidth = getWidth(tempChar);\n            }\n\n            this._cache[tempChar] = {\n              width: minWidth\n            };\n          }\n\n          strWidth += minWidth;\n\n          if (strWidth > maxWidthWithEll) {\n            if (!trimStr) {\n              trimStr = tempArr.slice(0, -1).join('');\n            }\n\n            if (strWidth > maxWidth) {\n              smartLabel.text = fastTrim(trimStr) + ellipsesStr;\n              smartLabel.tooltext = smartLabel.oriText;\n              smartLabel.width = max(maxStrWidth, strWidth);\n              smartLabel.height = strHeight;\n              smartLabel.isTruncated = true;\n              return smartLabel;\n            }\n          }\n        }\n\n        smartLabel.text = tempArr.join('');\n        smartLabel.width = max(maxStrWidth, strWidth);\n        smartLabel.height = strHeight;\n        return smartLabel;\n      } else {\n        for (; i < len; i += 1) {\n          tempChar = tempArr[i] = oriTextArr[i];\n\n          if (tempChar === ' ' && !context) {\n            tempChar = this.ctx ? ' ' : '&nbsp;';\n          } // In case of <br>, reset width to 0 and increase line height\n\n\n          if (tempArr[i] === '<br />') {\n            maxStrWidth = max(maxStrWidth, strWidth);\n            strHeight += this._lineHeight;\n\n            if (strHeight <= maxHeight) {\n              // If the totalHeight is less than allowed height, continue.\n              lastIndexBroken = i;\n              strWidth = 0;\n              trimStr = null;\n              continue;\n            } else if (strHeight > maxHeight) {\n              // Else return by truncating the text and attaching ellipses.\n              trimStr = tempArr.slice(0, -1).join('');\n              smartLabel.text = fastTrim(trimStr) + ellipsesStr;\n              smartLabel.tooltext = toolText;\n              smartLabel.width = maxStrWidth;\n              smartLabel.height = strHeight - this._lineHeight;\n              smartLabel.isTruncated = true;\n              return smartLabel;\n            }\n          }\n\n          if (this._cache[tempChar]) {\n            minWidth = this._cache[tempChar].width;\n          } else {\n            if (!getOriSizeImproveObj || !(minWidth = getOriSizeImproveObj.detailObj[tempChar])) {\n              minWidth = getWidth(tempChar);\n            }\n\n            this._cache[tempChar] = {\n              width: minWidth\n            };\n          }\n\n          strWidth += minWidth;\n\n          if (strWidth > maxWidthWithEll) {\n            if (!trimStr) {\n              trimStr = tempArr.slice(0, -1).join('');\n            }\n\n            if (strWidth > maxWidth) {\n              // do not perform any line break operation if next character is a break tag\n              if (oriTextArr[i + 1] === '<br />') {\n                continue;\n              }\n              /** @todo use regular expressions for better performance. */\n\n\n              lastSpace = slLib._findLastIndex(oriTextArr.slice(0, tempArr.length), ' ');\n              lastDash = slLib._findLastIndex(oriTextArr.slice(0, tempArr.length), '-');\n\n              if (lastSpace > lastIndexBroken) {\n                strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));\n                tempArr.splice(lastSpace, 1, '<br />');\n                lastIndexBroken = lastSpace;\n                newCharIndex = lastSpace + 1;\n              } else if (lastDash > lastIndexBroken) {\n                if (lastDash === tempArr.length - 1) {\n                  strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));\n                  tempArr.splice(lastDash, 1, '<br />-');\n                } else {\n                  strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));\n                  tempArr.splice(lastDash, 1, '-<br />');\n                }\n\n                lastIndexBroken = lastDash;\n                newCharIndex = lastDash + 1;\n              } else {\n                tempArr.splice(tempArr.length - 1, 1, '<br />' + oriTextArr[i]);\n                lastLineBreak = tempArr.length - 2;\n                strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastLineBreak + 1).join(''));\n                lastIndexBroken = lastLineBreak;\n                newCharIndex = i;\n              }\n\n              strHeight += this._lineHeight;\n\n              if (strHeight > maxHeight) {\n                smartLabel.text = fastTrim(trimStr) + ellipsesStr;\n                smartLabel.tooltext = smartLabel.oriText; // The max width among all the lines will be the width of the string.\n\n                smartLabel.width = maxWidth;\n                smartLabel.height = strHeight - this._lineHeight;\n                smartLabel.isTruncated = true;\n                return smartLabel;\n              } else {\n                maxStrWidth = max(maxStrWidth, strWidth);\n                trimStr = null;\n\n                if (!hasOnlyBrTag) {\n                  nearestChar = slLib.getNearestBreakIndex(text.substr(newCharIndex), maxWidthWithEll, this);\n                  strWidth = getWidth(text.substr(newCharIndex, nearestChar || 1));\n\n                  if (tempArr.length < newCharIndex + nearestChar) {\n                    tempArr = tempArr.concat(text.substr(tempArr.length, newCharIndex + nearestChar - tempArr.length).split(''));\n                    i = tempArr.length - 1;\n                  }\n                } else {\n                  // take the width already taken in the new line.\n                  strWidth = slLib._getDimentionOfMultiLineText(tempArr.slice(lastIndexBroken + 1).join(''), this).width;\n                }\n              }\n            }\n          }\n        }\n\n        maxStrWidth = max(maxStrWidth, strWidth);\n        smartLabel.text = tempArr.join('');\n        smartLabel.width = maxStrWidth;\n        smartLabel.height = strHeight;\n        return smartLabel;\n      }\n    } else {\n      toolText = text.replace(slLib.spanAdditionRegx, '$2');\n      text = text.replace(slLib.spanAdditionRegx, slLib.spanAdditionReplacer);\n      text = text.replace(/(<br\\s*\\/*\\>)/g, '<span class=\"' + [slLib.classNameWithTag, ' ', slLib.classNameWithTagBR].join('') + '\">$1</span>');\n      container.innerHTML = text;\n      spanArr = container[documentSupport.childRetriverFn](documentSupport.childRetriverString);\n\n      for (x = 0, y = spanArr.length; x < y; x += 1) {\n        elem = spanArr[x]; //chech whether this span is temporary inserted span from it's class\n\n        if (documentSupport.noClassTesting || slLib.classNameReg.test(elem.className)) {\n          chr = elem.innerHTML;\n\n          if (chr !== '') {\n            if (chr === ' ') {\n              spaceIndex = characterArr.length;\n            } else if (chr === '-') {\n              dashIndex = characterArr.length;\n            }\n\n            characterArr.push({\n              spaceIdx: spaceIndex,\n              dashIdx: dashIndex,\n              elem: elem\n            });\n            oriTextArr.push(chr);\n          }\n        }\n      }\n\n      i = 0;\n      len = characterArr.length; // if character array is not generated\n\n      minWidth = len && characterArr[0].elem.offsetWidth;\n\n      if (minWidth > maxWidth || !len) {\n        smartLabel.text = '';\n        smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;\n        return smartLabel;\n      } else if (minWidth > maxWidthWithEll && !this._showNoEllipses) {\n        maxWidthWithEll = maxWidth - 2 * dotWidth;\n\n        if (maxWidthWithEll > minWidth) {\n          ellipsesStr = '..';\n        } else {\n          maxWidthWithEll = maxWidth - dotWidth;\n\n          if (maxWidthWithEll > minWidth) {\n            ellipsesStr = '.';\n          } else {\n            maxWidthWithEll = 0;\n            ellipsesStr = '';\n          }\n        }\n      }\n\n      initialLeft = characterArr[0].elem.offsetLeft;\n      initialTop = characterArr[0].elem.offsetTop;\n\n      if (noWrap) {\n        for (; i < len; i += 1) {\n          elem = characterArr[i].elem;\n          elemRightMostPoint = elem.offsetLeft - initialLeft + elem.offsetWidth;\n\n          if (elemRightMostPoint > maxWidthWithEll) {\n            if (!removeFromIndexForEllipses) {\n              removeFromIndexForEllipses = i;\n            }\n\n            if (container.offsetWidth > maxWidth) {\n              removeFromIndex = i;\n              i = len;\n            }\n          }\n        }\n      } else {\n        for (; i < len; i += 1) {\n          elem = characterArr[i].elem;\n          elemLowestPoint = elem.offsetHeight + (elem.offsetTop - initialTop);\n          elemRightMostPoint = elem.offsetLeft - initialLeft + elem.offsetWidth;\n          lastBR = null;\n\n          if (elemRightMostPoint > maxWidthWithEll) {\n            if (!removeFromIndexForEllipses) {\n              removeFromIndexForEllipses = i;\n            }\n\n            if (elemRightMostPoint > maxWidth) {\n              lastSpace = characterArr[i].spaceIdx;\n              lastDash = characterArr[i].dashIdx;\n\n              if (lastSpace > lastIndexBroken) {\n                characterArr[lastSpace].elem.innerHTML = '<br/>';\n                lastIndexBroken = lastSpace;\n              } else if (lastDash > lastIndexBroken) {\n                if (lastDash === i) {\n                  // in case the overflowing character itself is the '-'\n                  characterArr[lastDash].elem.innerHTML = '<br/>-';\n                } else {\n                  characterArr[lastDash].elem.innerHTML = '-<br/>';\n                }\n\n                lastIndexBroken = lastDash;\n              } else {\n                elem.parentNode.insertBefore(lastBR = doc.createElement('br'), elem);\n              } //check whether this break made current element outside the area height\n\n\n              if (elem.offsetHeight + elem.offsetTop > maxHeight) {\n                //remove the lastly inserted line break\n                if (lastBR) {\n                  lastBR.parentNode.removeChild(lastBR);\n                } else if (lastIndexBroken === lastDash) {\n                  characterArr[lastDash].elem.innerHTML = '-';\n                } else {\n                  characterArr[lastSpace].elem.innerHTML = ' ';\n                }\n\n                removeFromIndex = i; //break the looping condition\n\n                i = len;\n              } else {\n                removeFromIndexForEllipses = null;\n              }\n            }\n          } else {\n            //check whether this break made current element outside the area height\n            if (elemLowestPoint > maxHeight) {\n              removeFromIndex = i;\n              i = len;\n            }\n          }\n        }\n      }\n\n      if (removeFromIndex < len) {\n        //set the trancated property of the smartlabel\n        smartLabel.isTruncated = true;\n        /** @todo is this really needed? */\n\n        removeFromIndexForEllipses = removeFromIndexForEllipses ? removeFromIndexForEllipses : removeFromIndex;\n\n        for (i = len - 1; i >= removeFromIndexForEllipses; i -= 1) {\n          elem = characterArr[i].elem; //chech whether this span is temporary inserted span from it's class\n\n          elem.parentNode.removeChild(elem);\n        }\n\n        for (; i >= 0; i -= 1) {\n          elem = characterArr[i].elem;\n\n          if (slLib.classNameBrReg.test(elem.className)) {\n            //chech whether this span is temporary inserted span from it's class\n            elem.parentNode.removeChild(elem);\n          } else {\n            i = 0;\n          }\n        }\n      } //get the smart text\n\n\n      smartLabel.text = container.innerHTML.replace(slLib.spanRemovalRegx, '$1').replace(/\\&amp\\;/g, '&');\n\n      if (smartLabel.isTruncated) {\n        smartLabel.text += ellipsesStr;\n        smartLabel.tooltext = toolText;\n      }\n    }\n\n    smartLabel.height = container.offsetHeight;\n    smartLabel.width = container.offsetWidth;\n    return smartLabel;\n  } else {\n    smartLabel.error = new Error('Body Tag Missing!');\n    return smartLabel;\n  }\n};\n/*\n * Get the height and width of a text.\n *\n * @param {String} text - Text whose metrics to be measured\n * @param {Boolean} Optional detailedCalculationFlag - this flag if set it calculates per letter position\n *                          information and returns it. Ideally you dont need it unless you want to post process the\n *                          string. And its an EXPENSIVE OPERATION.\n *\n * @return {Object} - If detailedCalculationFlag is set to true the returned object would be\n *                  {\n *                      height: height of the text\n *                      width: width of the text\n *                      detailObj: detail calculation of letters in the format {lettername: width}\n *                  }\n *                  If detailedCalculationFlag is set to false the returned object wont have the detailObj prop.\n */\n\n\nSmartLabelManager.prototype.getSize = function () {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var detailedCalculationFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!this._init) {\n    return false;\n  }\n\n  if (text === undefined || text === null) {\n    text = '';\n  } else if (typeof text !== 'string') {\n    text = text.toString();\n  }\n\n  var textArr,\n      letter,\n      lSize,\n      i,\n      l,\n      cumulativeSize = 0,\n      height = 0,\n      container,\n      indiSizeStore = {},\n      hasHTMLTag = config.hasHTMLTag,\n      hasOnlyBrTag = config.hasOnlyBrTag;\n\n  if (typeof hasHTMLTag === 'undefined') {\n    hasHTMLTag = slLib.xmlTagRegEx.test(text) || slLib.nbspRegex.test(text);\n  }\n\n  if (typeof hasOnlyBrTag === 'undefined') {\n    hasOnlyBrTag = slLib._hasOnlyBRTag(text);\n  }\n\n  this.requireDiv = hasHTMLTag && !hasOnlyBrTag;\n\n  if (!config.cleanText) {\n    text = text.replace(slLib.ltgtquotRegex, function (match) {\n      switch (match) {\n        case '&lt;':\n          return '<';\n\n        case '&gt;':\n          return '>';\n\n        case '&quot;':\n          return '\"';\n\n        case '&#034;':\n          return '\"';\n\n        case '&#039;':\n          return '\\'';\n      }\n    });\n  }\n\n  this._updateStyle();\n\n  container = this._container; // When text is normal text\n\n  if (!detailedCalculationFlag) {\n    return this._calCharDimWithCache(text);\n  } else {\n    // Calculate the width of every letter with an approximation\n    textArr = text.split('');\n\n    for (i = 0, l = textArr.length; i < l; i++) {\n      letter = textArr[i];\n      lSize = this._calCharDimWithCache(letter, false, textArr.length);\n      height = max(height, lSize.height);\n      cumulativeSize += lSize.width;\n      indiSizeStore[letter] = lSize.width;\n    }\n  } // If text has br tag, return the width and height with proper calculations\n\n\n  if (hasOnlyBrTag) {\n    return _objectSpread({}, slLib._getDimentionOfMultiLineText(text, this), {\n      detailObj: indiSizeStore\n    });\n  } // text contains html tags other than br\n\n\n  if (hasHTMLTag) {\n    container.innerHTML = text;\n    return {\n      width: container.offsetWidth,\n      height: container.offsetHeight,\n      detailObj: indiSizeStore\n    };\n  }\n\n  return {\n    width: round(cumulativeSize),\n    height: height,\n    detailObj: indiSizeStore\n  };\n};\n/**\n * getOriSize API will eventually be deprecated and will be renamed to getSize API. For the next two versions,\n * both getOriSize and getSize API will be supported.\n */\n\n\nSmartLabelManager.prototype.getOriSize = function () {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var detailedCalculationFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return this.getSize(text, detailedCalculationFlag, config);\n};\n/*\n * Dispose the container and object allocated by the smartlabel\n */\n\n\nSmartLabelManager.prototype.dispose = function () {\n  if (!this._init) {\n    return this;\n  }\n\n  if (this._containerManager && this._containerManager.dispose) {\n    this._containerManager.dispose();\n  }\n\n  delete this._container;\n  delete this._context;\n  delete this._cache;\n  delete this._containerManager;\n  delete this._containerObj;\n  delete this.id;\n  delete this.style;\n  delete this.parentContainer;\n  delete this._showNoEllipses;\n  return this;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SmartLabelManager);\n\n//# sourceURL=webpack://SmartLabel/./src/SmartlabelManager.js?");

/***/ }),

/***/ "./src/container-manager.js":
/*!**********************************!*\
  !*** ./src/container-manager.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.js\");\n\nvar slLib = _lib__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init(window),\n    doc = slLib.win.document,\n    documentSupport = slLib.getDocumentSupport(),\n    SVG_BBOX_CORRECTION = documentSupport.isWebKit ? 0 : 4.5;\n\nfunction ContainerManager(parentContainer, isBrowserLess, maxContainers) {\n  var svg;\n  maxContainers = maxContainers > 5 ? maxContainers : 5;\n  maxContainers = maxContainers < 20 ? maxContainers : 20;\n  this.maxContainers = maxContainers;\n  this.first = null;\n  this.last = null;\n  this.containers = {};\n  this.length = 0;\n  this.rootNode = parentContainer;\n\n  if (isBrowserLess) {\n    svg = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttributeNS('http://www.w3.org/2000/svg', 'xlink', 'http://www.w3.org/1999/xlink');\n    svg.setAttributeNS('http://www.w3.org/2000/svg', 'height', '0');\n    svg.setAttributeNS('http://www.w3.org/2000/svg', 'width', '0');\n    this.svgRoot = svg;\n    this.rootNode.appendChild(svg);\n  }\n}\n\nContainerManager.prototype.get = function (style) {\n  var diff,\n      key,\n      containerObj,\n      containers = this.containers,\n      len = this.length,\n      max = this.maxContainers,\n      keyStr = '';\n\n  for (key in slLib.supportedStyle) {\n    if (style[key] !== undefined) {\n      keyStr += slLib.supportedStyle[key] + ':' + style[key] + ';';\n    }\n  }\n\n  if (!keyStr) {\n    return false;\n  }\n\n  if (containerObj = containers[keyStr]) {\n    if (this.first !== containerObj) {\n      if (containerObj.prev) {\n        containerObj.prev.next = containerObj.next;\n      }\n\n      if (containerObj.next) {\n        containerObj.next.prev = containerObj.prev;\n      } // containerObj.prev && (containerObj.prev.next = containerObj.next);\n      // containerObj.next && (containerObj.next.prev = containerObj.prev);\n\n\n      containerObj.next = this.first;\n      containerObj.next.prev = containerObj;\n\n      if (this.last === containerObj) {\n        this.last = containerObj.prev;\n      } // (this.last === containerObj) && (this.last = containerObj.prev);\n\n\n      containerObj.prev = null;\n      this.first = containerObj;\n    }\n  } else {\n    if (len >= max) {\n      diff = len - max + 1; // +1 is to remove an extra entry to make space for the new container to be added.\n\n      while (diff--) {\n        this.removeContainer(this.last);\n      }\n    }\n\n    containerObj = this.addContainer(keyStr);\n  }\n\n  return containerObj;\n};\n\nContainerManager.prototype._makeDivNode = function (container) {\n  var node,\n      keyStr = container.keyStr;\n\n  if (!container.node) {\n    container.node = doc.createElement('div');\n    container.node.className = 'fusioncharts-div';\n    this.rootNode.appendChild(container.node);\n  }\n\n  node = container.node;\n\n  if (documentSupport.isIE && !documentSupport.hasSVG) {\n    node.style.setAttribute('cssText', keyStr);\n  } else {\n    node.setAttribute('style', keyStr);\n  }\n\n  node.setAttribute('aria-hidden', 'true');\n  node.setAttribute('role', 'presentation');\n  node.style.display = 'inline-block';\n  node.innerHTML = slLib.testStrAvg; // A test string.\n\n  container.lineHeight = node.offsetHeight;\n  container.avgCharWidth = node.offsetWidth / 3;\n\n  if (documentSupport.isBrowserLess) {\n    if (!container.svgText) {\n      container.svgText = doc.createElementNS('http://www.w3.org/2000/svg', 'text');\n      this.svgRoot.appendChild(node);\n    }\n\n    node = container.svgText;\n    node.setAttribute('style', keyStr);\n    node.textContent = slLib.testStrAvg; // A test string.\n\n    container.lineHeight = node.getBBox().height;\n    container.avgCharWidth = (node.getBBox().width - SVG_BBOX_CORRECTION) / 3;\n    node.textContent = '...';\n    container.ellipsesWidth = node.getBBox().width - SVG_BBOX_CORRECTION;\n    node.textContent = '.';\n    container.dotWidth = node.getBBox().width - SVG_BBOX_CORRECTION;\n  } else {\n    node.innerHTML = '...';\n    container.ellipsesWidth = node.offsetWidth;\n    node.innerHTML = '.';\n    container.dotWidth = node.offsetWidth;\n    node.innerHTML = '';\n  }\n};\n\nContainerManager.prototype.addContainer = function (keyStr) {\n  var container;\n  this.containers[keyStr] = container = {\n    next: null,\n    prev: null,\n    node: null,\n    ellipsesWidth: 0,\n    lineHeight: 0,\n    dotWidth: 0,\n    avgCharWidth: 4,\n    keyStr: keyStr,\n    charCache: {}\n  }; // Since the container objects are arranged from most recent to least recent order, we need to add the new\n  // object at the beginning of the list.\n\n  container.next = this.first;\n\n  if (container.next) {\n    container.next.prev = container;\n  }\n\n  this.first = container;\n\n  if (!this.last) {\n    this.last = container;\n  }\n\n  this.length += 1;\n  return container;\n};\n\nContainerManager.prototype.removeContainer = function (cObj) {\n  var keyStr = cObj.keyStr;\n\n  if (!keyStr || !this.length || !cObj) {\n    return;\n  }\n\n  this.length -= 1;\n\n  if (cObj.prev) {\n    cObj.prev.next = cObj.next;\n  }\n\n  if (cObj.next) {\n    cObj.next.prev = cObj.prev;\n  }\n\n  if (this.first === cObj) {\n    this.first = cObj.next;\n  }\n\n  if (this.last === cObj) {\n    this.last = cObj.prev;\n  }\n\n  if (cObj.node) {\n    cObj.node.parentNode.removeChild(cObj.node);\n  }\n\n  delete this.containers[keyStr];\n};\n\nContainerManager.prototype.dispose = function () {\n  var key,\n      containers = this.containers;\n  this.maxContainers = null;\n\n  for (key in containers) {\n    this.removeContainer(containers[key]);\n  }\n\n  this.rootNode.parentNode.removeChild(this.rootNode);\n  this.rootNode = null;\n  this.first = null;\n  this.last = null;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContainerManager);\n\n//# sourceURL=webpack://SmartLabel/./src/container-manager.js?");

/***/ }),

/***/ "./src/lib.js":
/*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar lib = {\n  init: function init(win) {\n    var doc = win.document,\n        nav = win.navigator,\n        userAgent = nav.userAgent,\n        DIV = 'DIV',\n        ceil = Math.ceil,\n        floor = Math.floor,\n        clsNameSpace = 'fusioncharts-smartlabel-',\n        containerClass = clsNameSpace + 'container',\n        classNameWithTag = clsNameSpace + 'tag',\n        classNameWithTagBR = clsNameSpace + 'br';\n    lib = {\n      win: win,\n      containerClass: containerClass,\n      classNameWithTag: classNameWithTag,\n      classNameWithTagBR: classNameWithTagBR,\n      maxDefaultCacheLimit: 1000,\n      // The regex we get from new RegExp does not perform the work as intended\n      // classNameReg: new RegExp('\\b' + classNameWithTag + '\\b'),\n      // classNameBrReg: new RegExp('\\b' + classNameWithTagBR + '\\b'),\n      classNameReg: /\\bfusioncharts-smartlabel-tag\\b/,\n      classNameBrReg: /\\bfusioncharts-smartlabel-br\\b/,\n      spanAdditionRegx: /(<[^<\\>]+?\\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig,\n      spanAdditionReplacer: '$1<span class=\"' + classNameWithTag + '\">$2</span>',\n      spanRemovalRegx: new RegExp('\\\\<span[^\\\\>]+?' + classNameWithTag + '[^\\\\>]{0,}\\\\>(.*?)\\\\<\\\\/span\\\\>', 'ig'),\n      xmlTagRegEx: new RegExp('<[^>][^<]*[^>]+>', 'i'),\n      brRegex: new RegExp('({br[ ]*})|(<br[ ]*>)|(<br[ ]*\\/>)|(<BR[ ]*\\/>)|(<br\\\\>)', 'g'),\n      ltgtquotRegex: /&lt;|&gt;|&quot;|&#034;|&#039;/g,\n      nbspRegex: /&nbsp;|&#160;|&#xA0;/g,\n      htmlSpecialEntityRegex: /&amp;|&quot;|&lt;|&gt;/g,\n      brReplaceRegex: /<br\\/>/ig,\n      testStrAvg: 'WgI',\n      // This style is applied over the parent smartlabel container. The container is kept hidden from the viewport\n      parentContainerStyle: {\n        position: 'absolute',\n        top: '-9999em',\n        whiteSpace: 'nowrap',\n        padding: '0px',\n        width: '1px',\n        height: '1px',\n        overflow: 'hidden'\n      },\n      // All the style which might affect the text metrics\n      supportedStyle: {\n        font: 'font',\n        fontFamily: 'font-family',\n        'font-family': 'font-family',\n        fontWeight: 'font-weight',\n        'font-weight': 'font-weight',\n        fontSize: 'font-size',\n        'font-size': 'font-size',\n        lineHeight: 'line-height',\n        'line-height': 'line-height',\n        fontStyle: 'font-style',\n        'font-style': 'font-style'\n      },\n      // Get the support list for html the document where the text calcution is to be done.\n      getDocumentSupport: function getDocumentSupport() {\n        var childRetriverFn, childRetriverString, noClassTesting;\n\n        if (doc.getElementsByClassName) {\n          childRetriverFn = 'getElementsByClassName';\n          childRetriverString = classNameWithTag;\n          noClassTesting = true;\n        } else {\n          childRetriverFn = 'getElementsByTagName';\n          childRetriverString = 'span';\n          noClassTesting = false;\n        }\n\n        return {\n          isIE: /msie/i.test(userAgent) && !win.opera,\n          hasSVG: Boolean(win.SVGAngle || doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')),\n          isHeadLess: new RegExp(' HtmlUnit').test(userAgent),\n          isWebKit: new RegExp(' AppleWebKit/').test(userAgent),\n          childRetriverFn: childRetriverFn,\n          childRetriverString: childRetriverString,\n          noClassTesting: noClassTesting\n        };\n      },\n\n      /*\n       * Create a html div element and attach it with a parent. All the subsequent operations are performed\n       * by upding this dom tree only.\n       *\n       * @param {HTMLElement} - The html element where the newly created div is to be attached. If not passed,\n       *                      the new div is appended on the body.\n       */\n      createContainer: function createContainer(containerParent) {\n        var body, container;\n\n        if (containerParent && (containerParent.offsetWidth || containerParent.offsetHeight)) {\n          if (containerParent.appendChild) {\n            containerParent.appendChild(container = doc.createElement(DIV));\n            container.className = containerClass;\n            container.setAttribute('aria-hidden', 'true');\n            container.setAttribute('role', 'presentation');\n            return container;\n          }\n        } else {\n          body = doc.getElementsByTagName('body')[0];\n\n          if (body && body.appendChild) {\n            container = doc.createElement(DIV);\n            container.className = containerClass;\n            container.setAttribute('aria-hidden', 'true');\n            container.setAttribute('role', 'presentation');\n            body.appendChild(container);\n            return container;\n          }\n        }\n      },\n      // Finds a approximate position where the text is to be broken\n      getNearestBreakIndex: function getNearestBreakIndex(text, maxWidth, sl) {\n        if (!text || !text.length) {\n          return 0;\n        }\n\n        var difference,\n            getWidth = sl._getWidthFn(),\n            charLen = 0,\n            increment = 0,\n            oriWidth = getWidth(text),\n            avgWidth = oriWidth / text.length;\n\n        difference = maxWidth;\n        charLen = ceil(maxWidth / avgWidth);\n\n        if (oriWidth < maxWidth) {\n          return text.length - 1;\n        }\n\n        if (charLen > text.length) {\n          difference = maxWidth - oriWidth;\n          charLen = text.length;\n        }\n\n        while (difference > 0) {\n          difference = maxWidth - getWidth(text.substr(0, charLen));\n          increment = floor(difference / avgWidth);\n\n          if (increment) {\n            charLen += increment;\n          } else {\n            return charLen;\n          }\n        }\n\n        while (difference < 0) {\n          difference = maxWidth - getWidth(text.substr(0, charLen));\n          increment = floor(difference / avgWidth);\n\n          if (increment) {\n            charLen += increment;\n          } else {\n            return charLen;\n          }\n        }\n\n        return charLen;\n      },\n\n      /**\n       * parses the style information\n       */\n      parseStyle: function parseStyle() {\n        var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var parsedStyle = {};\n        parsedStyle.fontSize = (style.fontSize || style['font-size'] || '12px') + '';\n        parsedStyle.fontVariant = style.fontVariant || style['font-variant'] || 'normal';\n        parsedStyle.fontWeight = style.fontWeight || style['font-weight'] || 'normal';\n        parsedStyle.fontStyle = style.fontStyle || style['font-style'] || 'normal';\n        parsedStyle.fontFamily = style.fontFamily || style['font-family'] || 'Verdana,sans';\n        return parsedStyle;\n      },\n\n      /*\n       * Determine lineheight of a text for a given style. It adds propery lineHeight to the style passed\n       *\n       * @param {Object} - The style based on which the text's metric needs to be calculated. The calculation happens\n       *                  based on fontSize property, if its not present a default font size is assumed.\n       *\n       * @return {Object} - The style that was passed with lineHeight as a named propery set on the object.\n       */\n      setLineHeight: function setLineHeight(styleObj) {\n        var fSize = styleObj.fontSize;\n        styleObj.lineHeight = styleObj.lineHeight || styleObj['line-height'] || parseInt(fSize, 10) * 1.2 + 'px';\n        return styleObj;\n      },\n\n      /**\n       * Returns the clean height by removing 'px' if present.\n       */\n      _getCleanHeight: function _getCleanHeight(height) {\n        // Remove 'px' from  height and convert it to number\n        height = height.replace(/px/g, '');\n        return Number(height);\n      },\n\n      /**\n       * Div is used for calculation of text dimention in all non-canvas browsers. It sets the text as\n       * innerHTML of the div and uses it's offsetWidth and offsetHeight as width and height respectively\n       *\n       * @param {string} text - text, whose measurements are to be calculated\n       * \n       * @returns {Object} - dimension of text\n       */\n      _getDimentionUsingDiv: function _getDimentionUsingDiv() {\n        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var sl = arguments.length > 1 ? arguments[1] : undefined;\n        var container = sl._container; // In case text is an array, convert it to string.\n\n        if (text instanceof Array) {\n          text = text.join('');\n        }\n\n        container.innerHTML = text;\n        return {\n          width: container.offsetWidth,\n          height: container.offsetHeight\n        };\n      },\n\n      /**\n       * Returns the height and width of a text using the canvas.measureText API.\n       * Used for calculating width in browsers supporting html canvas.\n       * In case canvas is not present, <div> is used for calculation as a fallback solution\n       * \n       * @param {any} text -  text. Can be array or string.\n       * \n       * @return {Object} - width and height.\n       */\n      _getDimentionUsingCanvas: function _getDimentionUsingCanvas() {\n        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var sl = arguments.length > 1 ? arguments[1] : undefined;\n\n        var ctx = sl.ctx,\n            style = sl.style,\n            height = lib._getCleanHeight(style.lineHeight); // In case text is string, remove <br /> from it.\n\n\n        if (!(text instanceof Array)) {\n          text = text.replace(/<br \\/>/g, '');\n        } else {\n          // Else if it an array, convert it to string and remove <br />\n          text = text.join('');\n          text = text.replace(/<br \\/>/g, '');\n        }\n\n        return {\n          width: ctx.measureText(text).width,\n          height: height\n        };\n      },\n\n      /**\n       * Checks if text contains any <br /> tag. If yes, it returns all the indexes of it.\n       * Else, it returns undefined.\n       * \n       * @param {string} input -  text which is to be examined for <br /> tag\n       * \n       * @returns {boolean} - whether text contains only <br> tag\n       */\n      _hasOnlyBRTag: function _hasOnlyBRTag() {\n        var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        return !lib.xmlTagRegEx.test(input) && lib.brRegex.test(input);\n      },\n\n      /**\n       * For a text containing <br /> it returns the height and width of the text\n       * \n       */\n      _getDimentionOfMultiLineText: function _getDimentionOfMultiLineText() {\n        var rawText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var sl = arguments.length > 1 ? arguments[1] : undefined;\n\n        var i,\n            len,\n            text = rawText.replace(lib.brRegex, '<br />'),\n            textAr = lib._getTextArray(text),\n            width = 0,\n            maxWidth = 0,\n            getWidth = sl._getWidthFn(),\n            height = lib._getCleanHeight(sl.style.lineHeight),\n            textHeight = height,\n            textWidth,\n            indiSizeStore = {};\n\n        for (i = 0, len = textAr.length; i < len; i++) {\n          if (textAr[i] === '<br />') {\n            // In case of <br />, reset width to 0, since it will be new line now.\n            // Also, increase the line height.\n            maxWidth = Math.max(maxWidth, width);\n            width = 0;\n            textHeight += height;\n          } else {\n            // Else, calculate the width of the line.\n            textWidth = getWidth(textAr[i]);\n            width += textWidth;\n            indiSizeStore[textAr[i]] = textWidth;\n          }\n        }\n\n        maxWidth = Math.max(maxWidth, width);\n        return {\n          height: textHeight,\n          width: maxWidth,\n          detailObj: indiSizeStore\n        };\n      },\n\n      /**\n       * Splits text into array and returns. Special functionality is, it treats <br /> as a single character\n       */\n      _getTextArray: function _getTextArray() {\n        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var i,\n            j,\n            len,\n            tempLen,\n            brText,\n            tempText,\n            finaltextAr = []; // Split using <br />\n\n        brText = text.split('<br />');\n        len = brText.length;\n\n        for (i = 0; i < len; i++) {\n          tempText = brText[i].split('');\n          tempLen = tempText.length; // for each array retrieved by spliting using <br /> push elements to finalArray.\n\n          for (j = 0; j < tempLen; j++) {\n            finaltextAr.push(tempText[j]);\n          } // Check if tempText is not the last text. IF true, add <br /> to the final Array.\n\n\n          if (i !== len - 1) {\n            finaltextAr.push('<br />');\n          }\n        }\n\n        return finaltextAr;\n      },\n\n      /**\n       * Returns the last occurance of item in a array\n       */\n      _findLastIndex: function _findLastIndex() {\n        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var item = arguments.length > 1 ? arguments[1] : undefined;\n        var i,\n            len = array.length;\n\n        for (i = len - 1; i >= 0; i--) {\n          if (array[i] === item) {\n            return i;\n          }\n        }\n\n        return -1;\n      }\n    };\n    return lib;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (lib);\n\n//# sourceURL=webpack://SmartLabel/./src/lib.js?");

/***/ })

/******/ })["default"];
});